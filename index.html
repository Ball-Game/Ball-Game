<html lang='en'>
	<head>
		<title>Ball Game</title>
		<meta charset='utf-8'>
		<meta name='viewport' content='width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0'>
		<style>

html,body{

	margin: 0;
	color: #fff;
	font-family: monospace,monospace;

}

nav {

	position: fixed;
	width: 100%;
	height: 100%;
	z-index: 100;

	background-color: #222;
	background-image: radial-gradient(#333,#111 50%,#222 50%);
	background-size: 100vmin;
	background-position: center;
	background-repeat: no-repeat;

	text-align: center;
	display: flex;
	flex-direction: column;
	justify-content: center;

}

nav>*{
	margin:1rem 0;
}

button{
	background: NONE;
	border: 0;
	color: inherit;
	font-family: inherit;
	cursor: pointer;
}
button:hover{
	opacity:0.5;
}

#CANVAS{
	position:fixed;
}
		</style>
	</head>
	<body>

		<nav id='menu'>
			<div>Ball Game</div>
			<button id='menu-play'>I would like to throw balls at balls</button>
			<button id='menu-buy'>Store</button>
		</nav>

		<main id='canvas'></main>

		<script src='js/ammo.js'></script>


		<script type='module'>

import * as THREE from './js/three.module.js'
import { OrbitControls } from './js/OrbitControls.js'
import { BufferGeometryUtils } from './js/BufferGeometryUtils.js'

// menu screen

const MENU = document.getElementById('menu'),
			MENU_PLAY = document.getElementById('menu-play'),
			MENU_BUY = document.getElementById('menu-buy'),

			CANVAS = document.getElementById('canvas')



// Graphics variables
let camera, controls, scene, renderer
let textureLoader
let clock = new THREE.Clock()
let clickRequest = false
let mouseCoords = new THREE.Vector2()
let raycaster = new THREE.Raycaster()
let ballMaterial = new THREE.MeshPhongMaterial( { color: 0x202020 } )
let pos = new THREE.Vector3()
let quat = new THREE.Quaternion()
// Physics variables
const GRAVITY = - 9.8
let physicsWorld
let rigidBodies = []
let softBodies = []
let margin = 0.05
let transformAux1
let softBodyHelpers

Ammo().then( ( AmmoLib ) => {

	Ammo = AmmoLib

	initGraphics()
	initPhysics()
	createObjects()

	MENU_PLAY.addEventListener('click',()=>{

		MENU.style.visibility = 'hidden'

		initInput()
		animate()

	})

} )

function initGraphics() {

	camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 )
	scene = new THREE.Scene()
	scene.background = new THREE.Color( 0xbfd1e5 )
	camera.position.set( - 7, 5, 8 )
	renderer = new THREE.WebGLRenderer()
	renderer.setPixelRatio( window.devicePixelRatio )
	renderer.setSize( window.innerWidth, window.innerHeight )
	renderer.shadowMap.enabled = true
	CANVAS.appendChild( renderer.domElement )
	controls = new OrbitControls( camera, renderer.domElement )
	controls.target.set( 0, 2, 0 )
	controls.update()
	textureLoader = new THREE.TextureLoader()
	let ambientLight = new THREE.AmbientLight( 0x404040 )
	scene.add( ambientLight )
	let light = new THREE.DirectionalLight( 0xffffff, 1 )
	light.position.set( - 10, 10, 5 )
	light.castShadow = true
	let d = 20
	light.shadow.camera.left = - d
	light.shadow.camera.right = d
	light.shadow.camera.top = d
	light.shadow.camera.bottom = - d
	light.shadow.camera.near = 2
	light.shadow.camera.far = 50
	light.shadow.mapSize.x = 1024
	light.shadow.mapSize.y = 1024
	scene.add( light )
	window.addEventListener( 'resize', onWindowResize, false )

}
function initPhysics() {

	// Physics configuration
	let collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration()
	let dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration )
	let broadphase = new Ammo.btDbvtBroadphase()
	let solver = new Ammo.btSequentialImpulseConstraintSolver()
	let softBodySolver = new Ammo.btDefaultSoftBodySolver()
	physicsWorld = new Ammo.btSoftRigidDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration, softBodySolver )
	physicsWorld.setGravity( new Ammo.btVector3( 0, GRAVITY, 0 ) )
	physicsWorld.getWorldInfo().set_m_gravity( new Ammo.btVector3( 0, GRAVITY, 0 ) )
	transformAux1 = new Ammo.btTransform()
	softBodyHelpers = new Ammo.btSoftBodyHelpers()

}
function createObjects() {
	// Ground
	pos.set( 0, - 0.5, 0 )
	quat.set( 0, 0, 0, 1 )
	let ground = createParalellepiped( 40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) )
	ground.castShadow = true
	ground.receiveShadow = true
	textureLoader.load( 'textures/ground/sand.png', function ( texture ) {
		texture.wrapS = THREE.RepeatWrapping
		texture.wrapT = THREE.RepeatWrapping
		texture.repeat.set( 40, 40 )
		ground.material.map = texture
		ground.material.needsUpdate = true

	} )
	// Create soft volumes
	let volumeMass = 15
	let sphereGeometry = new THREE.SphereBufferGeometry( 1.5, 40, 25 )
	sphereGeometry.translate( 5, 5, 0 )
	createSoftVolume( sphereGeometry, volumeMass, 250 )
	let boxGeometry = new THREE.BoxBufferGeometry( 1, 1, 5, 4, 4, 20 )
	boxGeometry.translate( - 2, 5, 0 )
	createSoftVolume( boxGeometry, volumeMass, 120 )
	// Ramp
	pos.set( 3, 1, 0 )
	quat.setFromAxisAngle( new THREE.Vector3( 0, 0, 1 ), 30 * Math.PI / 180 )
	let obstacle = createParalellepiped( 10, 1, 4, 0, pos, quat, new THREE.MeshPhongMaterial( { color: 0x606060 } ) )
	obstacle.castShadow = true
	obstacle.receiveShadow = true
}
function processGeometry( bufGeometry ) {
	// Ony consider the position values when merging the vertices
	let posOnlyBufGeometry = new THREE.BufferGeometry()
	posOnlyBufGeometry.setAttribute( 'position', bufGeometry.getAttribute( 'position' ) )
	posOnlyBufGeometry.setIndex( bufGeometry.getIndex() )
	// Merge the vertices so the triangle soup is converted to indexed triangles
	let indexedBufferGeom = BufferGeometryUtils.mergeVertices( posOnlyBufGeometry )
	// Create index arrays mapping the indexed vertices to bufGeometry vertices
	mapIndices( bufGeometry, indexedBufferGeom )
}
function isEqual( x1, y1, z1, x2, y2, z2 ) {
	let delta = 0.000001
	return Math.abs( x2 - x1 ) < delta &&
			Math.abs( y2 - y1 ) < delta &&
			Math.abs( z2 - z1 ) < delta
}
function mapIndices( bufGeometry, indexedBufferGeom ) {
	// Creates ammoVertices, ammoIndices and ammoIndexAssociation in bufGeometry
	let vertices = bufGeometry.attributes.position.array
	let idxVertices = indexedBufferGeom.attributes.position.array
	let indices = indexedBufferGeom.index.array
	let numIdxVertices = idxVertices.length / 3
	let numVertices = vertices.length / 3
	bufGeometry.ammoVertices = idxVertices
	bufGeometry.ammoIndices = indices
	bufGeometry.ammoIndexAssociation = []
	for ( let i = 0; i < numIdxVertices; i ++ ) {
		let association = []
		bufGeometry.ammoIndexAssociation.push( association )
		let i3 = i * 3
		for ( let j = 0; j < numVertices; j ++ ) {
			let j3 = j * 3
			if ( isEqual( idxVertices[ i3 ], idxVertices[ i3 + 1 ], idxVertices[ i3 + 2 ],
				vertices[ j3 ], vertices[ j3 + 1 ], vertices[ j3 + 2 ] ) ) {
				association.push( j3 )
			}
		}
	}
}
function createSoftVolume( bufferGeom, mass, pressure ) {
	processGeometry( bufferGeom )
	let volume = new THREE.Mesh( bufferGeom, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) )
	volume.castShadow = true
	volume.receiveShadow = true
	volume.frustumCulled = false
	scene.add( volume )
	textureLoader.load( 'textures/inflatables/colors.png', function ( texture ) {
		volume.material.map = texture
		volume.material.needsUpdate = true
	} )
	// Volume physic object
	let volumeSoftBody = softBodyHelpers.CreateFromTriMesh(
		physicsWorld.getWorldInfo(),
		bufferGeom.ammoVertices,
		bufferGeom.ammoIndices,
		bufferGeom.ammoIndices.length / 3,
		true )
	let sbConfig = volumeSoftBody.get_m_cfg()
	sbConfig.set_viterations( 40 )
	sbConfig.set_piterations( 40 )
	// Soft-soft and soft-rigid collisions
	sbConfig.set_collisions( 0x11 )
	// Friction
	sbConfig.set_kDF( 0.1 )
	// Damping
	sbConfig.set_kDP( 0.01 )
	// Pressure
	sbConfig.set_kPR( pressure )
	// Stiffness
	volumeSoftBody.get_m_materials().at( 0 ).set_m_kLST( 0.9 )
	volumeSoftBody.get_m_materials().at( 0 ).set_m_kAST( 0.9 )
	volumeSoftBody.setTotalMass( mass, false )
	Ammo.castObject( volumeSoftBody, Ammo.btCollisionObject ).getCollisionShape().setMargin( margin )
	physicsWorld.addSoftBody( volumeSoftBody, 1, - 1 )
	volume.userData.physicsBody = volumeSoftBody
	// Disable deactivation
	volumeSoftBody.setActivationState( 4 )
	softBodies.push( volume )
}
function createParalellepiped( sx, sy, sz, mass, pos, quat, material ) {
	let threeObject = new THREE.Mesh( new THREE.BoxBufferGeometry( sx, sy, sz, 1, 1, 1 ), material )
	let shape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) )
	shape.setMargin( margin )
	createRigidBody( threeObject, shape, mass, pos, quat )
	return threeObject
}
function createRigidBody( threeObject, physicsShape, mass, pos, quat ) {
	threeObject.position.copy( pos )
	threeObject.quaternion.copy( quat )
	let transform = new Ammo.btTransform()
	transform.setIdentity()
	transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) )
	transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) )
	let motionState = new Ammo.btDefaultMotionState( transform )
	let localInertia = new Ammo.btVector3( 0, 0, 0 )
	physicsShape.calculateLocalInertia( mass, localInertia )
	let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia )
	let body = new Ammo.btRigidBody( rbInfo )
	threeObject.userData.physicsBody = body
	scene.add( threeObject )
	if ( mass > 0 ) {
		rigidBodies.push( threeObject )
		// Disable deactivation
		body.setActivationState( 4 )
	}
	physicsWorld.addRigidBody( body )
	return body
}
function initInput() {
	window.addEventListener( 'mousedown', function ( event ) {
		if ( ! clickRequest ) {
			mouseCoords.set(
				( event.clientX / window.innerWidth ) * 2 - 1,
				- ( event.clientY / window.innerHeight ) * 2 + 1
			)
			clickRequest = true
		}
	}, false )
}
function processClick() {
	if ( clickRequest ) {
		raycaster.setFromCamera( mouseCoords, camera )
		// Creates a ball
		let ballMass = 3
		let ballRadius = 0.4
		let ball = new THREE.Mesh( new THREE.SphereBufferGeometry( ballRadius, 18, 16 ), ballMaterial )
		ball.castShadow = true
		ball.receiveShadow = true
		let ballShape = new Ammo.btSphereShape( ballRadius )
		ballShape.setMargin( margin )
		pos.copy( raycaster.ray.direction )
		pos.add( raycaster.ray.origin )
		quat.set( 0, 0, 0, 1 )
		let ballBody = createRigidBody( ball, ballShape, ballMass, pos, quat )
		ballBody.setFriction( 0.5 )
		pos.copy( raycaster.ray.direction )
		pos.multiplyScalar( 14 )
		ballBody.setLinearVelocity( new Ammo.btVector3( pos.x, pos.y, pos.z ) )
		clickRequest = false
	}
}
function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight
	camera.updateProjectionMatrix()
	renderer.setSize( window.innerWidth, window.innerHeight )
}
function animate() {
	requestAnimationFrame( animate )
	render()
}
function render() {
	let deltaTime = clock.getDelta()
	updatePhysics( deltaTime )
	processClick()
	renderer.render( scene, camera )
}
function updatePhysics( deltaTime ) {
	// Step world
	physicsWorld.stepSimulation( deltaTime, 10 )
	// Update soft volumes
	for ( let i = 0, il = softBodies.length; i < il; i ++ ) {
		let volume = softBodies[ i ]
		let geometry = volume.geometry
		let softBody = volume.userData.physicsBody
		let volumePositions = geometry.attributes.position.array
		let volumeNormals = geometry.attributes.normal.array
		let association = geometry.ammoIndexAssociation
		let numVerts = association.length
		let nodes = softBody.get_m_nodes()
		for ( let j = 0; j < numVerts; j ++ ) {
			let node = nodes.at( j )
			let nodePos = node.get_m_x()
			let x = nodePos.x()
			let y = nodePos.y()
			let z = nodePos.z()
			let nodeNormal = node.get_m_n()
			let nx = nodeNormal.x()
			let ny = nodeNormal.y()
			let nz = nodeNormal.z()
			let assocVertex = association[ j ]
			for ( let k = 0, kl = assocVertex.length; k < kl; k ++ ) {
				let indexVertex = assocVertex[ k ]
				volumePositions[ indexVertex ] = x
				volumeNormals[ indexVertex ] = nx
				indexVertex ++
				volumePositions[ indexVertex ] = y
				volumeNormals[ indexVertex ] = ny
				indexVertex ++
				volumePositions[ indexVertex ] = z
				volumeNormals[ indexVertex ] = nz
			}
		}
		geometry.attributes.position.needsUpdate = true
		geometry.attributes.normal.needsUpdate = true
	}
	// Update rigid bodies
	for ( let i = 0, il = rigidBodies.length; i < il; i ++ ) {
		let objThree = rigidBodies[ i ]
		let objPhys = objThree.userData.physicsBody
		let ms = objPhys.getMotionState()
		if ( ms ) {
			ms.getWorldTransform( transformAux1 )
			let p = transformAux1.getOrigin()
			let q = transformAux1.getRotation()
			objThree.position.set( p.x(), p.y(), p.z() )
			objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() )
		}
	}
}

		</script>

	</body>
</html>
